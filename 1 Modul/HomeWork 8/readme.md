Задание 1.
==================

системный вызов команды CD -> chdir("/tmp")

![image](https://user-images.githubusercontent.com/60341565/142728150-15df3eac-0591-428c-a324-2c332c973526.png)

Задание 2.
==================

![image](https://user-images.githubusercontent.com/60341565/142728810-8cab5059-6210-4fd7-9352-ac955f70ac24.png)

После команды strace file /dev/tty 2>&1 |grep file показаны возможные места хранения базы данных для утилиты file.

Задание 3.
=================

Командой lsof -p |grep deleted можно узнать PID и номер дескриптора удалённого файла, скорее всего будет номер 4

Командой > /proc/PID/fd/4 можно обнулить файл, но сам файл останется в файловой системе пока процесс не завершится, но размер файла будет 0 байт и место на диске высвободится.

Задание 4.
=================

Зомби процессы не потребляют никаких ресурсов, память и файловые дескрипторы таких процессов уже освобождены. Остается только запись в таблице процессов, которая занимает несколько десятков байт памяти. Так что единичный зомби процесс на систему никак не влияет. НО он явный индикатор того, что у какого то процесса в системе что то пошло не так.

Задание 5.
==================

![image](https://user-images.githubusercontent.com/60341565/142734799-577c9eb6-a8c9-41aa-b227-5ff32cac0992.png)

Задание 6.
=================

системный вызов uname()

Цитата :
     Part of the utsname information is also accessible  via  /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.
       
Задание 7.
====================

; - Оператор выполняет несколько команд одновременно последовательно и обеспечивает вывод без зависимости от успеха или отказа других команд.

&& - Оператор выполнит вторую команду только в том случае, если команда 1 успешно выполнена. Если первая команда не работает, поэтому вторая команда тоже не выполняется.

Команда set -e останавливает выполнение скрипта, если команда или конвейер имеет ошибку, противоположную поведению оболочки по умолчанию, которая должна игнорировать ошибки в скриптах. Использование &&  вместе с set -e  не имеет смысла, так как при любой ошибке, выполнение команд прекратиться. 

Задание 8.
===================

set -e

Параметр -e немедленно завершит работу, если любая команда выйдет с ошибкой. По-умолчанию, игнорируются любые неудачи и сценарий продолжет выполнятся.

set -u

Параметр -u проверяет инициализацию переменных в скрипте. Если переменной не будет, скрипт немедленно завершиться.

set -x

Параметр -x печатает в стандартный вывод все команды перед их исполнением. Стоит учитывать, что все переменные будут уже доставлены.

set -o pipefail

Bash возвращает только код ошибки последней команды в пайпе (конвейере). И параметр -e проверяет только его. Если нужно убедиться, что все команды в пайпах завершились успешно, нужно использовать -o pipefail.

Все эти параметры можно объединять и комбинировать между собой, что даст улучшенную детализацию вывода ошибок и завершит сценарий при наличии ошибок, кроме последней команды.

Задание 9.
=================

![image](https://user-images.githubusercontent.com/60341565/142737069-d8f82386-9051-489c-b32c-b766a1f3e250.png)

S - Спящие, процессы ожидающие завершения, при необходимости можно разбудить.

I - Фоновые(бездействующие) процессы ядра.

R - Запущенные, то есть активные в данный момент.

Дополнительные символы - это параметры, например приоритет.

