Задание 1.
===
- напишите список операций, которые вы будете производить для остановки запроса пользователя

Необходимо посмотреть текущие запущенные операции, найти пид процесса который завис, принудительно завершить процесс. Для этого необходимо открыть новую вкладку терминала и запустить `db.currentOp()` , найти идентификатор операции , а затем запустить `db.killOp()`

- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Можно использовать оператор `maxTimeMS()` с указанием максимального времени операции в миллисекундах

Задание 2.
===

Redis основан на однопоточной архитектуре, то есть запросы будут выполняться по очереди. При большом количестве данных время выполнения некоторых операций будет относительно большим. Поскольку Redis использует только один поток для запроса данных, он заблокирует Redis и вызовет большую задержку.

Если превысили лимит памяти `maxmemory` Redis выдаст ошибку записи. Во избежания этих проблем необходимо использовать Распределенные блокировки.

Задание 3.
===

В документации MySQL ошибке посвящена эта статья, в ней перечислены три возможные причины:

- Слишком объёмные запросы на миллионы строк, и рекомендуют увеличить параметр `net_read_timeout`
- Небольшое значение параметра `connect_timeout`, клиент не успевает установить соединение
- Размер сообщения/запроса превышает размер буфера, заданного в переменной `max_allowed_packet` на сервере или опцией `--max_allowed_packet клиента`

Решение может быть: 
- Увеличить на сервере MySQL `wait_timeout`, `max_allowed_packet`, `net_write_timeout` и `net_read_timeout`
- Уменьшить `pool_recycle`, сделать меньше `wait_timeout`

Задание 4.
===

Если в системе мало памяти и освободить ее невозможно, вызывается функция `out_of_memory`. На этом этапе ей остается только одно — завершить один или несколько процессов.

Есть ядре два основных параметра, отвечающих за overcommit памяти:
- `vm.overcommit_memory` — отвечает за стратегию overcommit.
- `vm.overcommit_ratio` — отвечает за уровень (в процентах) overcommit-а
Стратегии есть такие (см. файл с исходниками ядра mm/mmap.c):

0 - OVERCOMMIT_GUESS — эвристический подход к распределению памяти. В нем выделяется столько памяти, сколько хочет процесс. Но в swap/res попадает только те страницы, которые используются этим процессом.
1 - OVERCOMMIT_ALWAYS — overcommit памяти есть всегда. Использовать лучше с совсем кривыми приложениями и быть готовым при этому ко всему.
2 - OVERCOMMIT_NEVER — без overcommit. В этом случае допустимый объем пространства памяти будет swap+ram*overcommit_ratio/100 .

По умолчанию используется стратегия OVERCOMMIT_GUESS, а `vm.overcommit_ratio` находится в значение 50% и используется только в случае OVERCOMMIT_NEVER. Система резервирует около 3% памяти для процессов пользователя root.

OOM-Killer «убивает» самые нехорошие процессы и спасает систему от аварийного завершения. Чтобы не приходилось использовать OOM-Killer для завершения PostgreSQL, необходимо установить для `vm.overcommit_memory` значение 2. Это не гарантирует, что OOM-Killer не придется вмешиваться, но снизит вероятность принудительного завершения процесса PostgreSQL.
