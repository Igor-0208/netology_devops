Задание 1.
===
- напишите список операций, которые вы будете производить для остановки запроса пользователя

Необходимо посмотреть текущие запущенные операции, найти пид процесса который завис, принудительно завершить процесс. Для этого необходимо открыть новую вкладку терминала и запустить `db.currentOp()` , найти идентификатор операции , а затем запустить `db.killOp()`

- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Можно использовать оператор `maxTimeMS()` с указанием максимального времени операции в миллисекундах

Задание 2.
===

Redis основан на однопоточной архитектуре, то есть запросы будут выполняться по очереди. При большом количестве данных время выполнения некоторых операций будет относительно большим. Поскольку Redis использует только один поток для запроса данных, он заблокирует Redis и вызовет большую задержку.

Если превысили лимит памяти `maxmemory` Redis выдаст ошибку записи. Во избежания этих проблем необходимо использовать Распределенные блокировки.

Задание 3.
===

В документации MySQL ошибке посвящена эта статья, в ней перечислены три возможные причины:

- Слишком объёмные запросы на миллионы строк, и рекомендуют увеличить параметр `net_read_timeout`
- Небольшое значение параметра `connect_timeout`, клиент не успевает установить соединение
- Размер сообщения/запроса превышает размер буфера, заданного в переменной `max_allowed_packet` на сервере или опцией `--max_allowed_packet клиента`

Решение может быть: 
- Увеличить на сервере MySQL `wait_timeout`, `max_allowed_packet`, `net_write_timeout` и `net_read_timeout`
- Уменьшить `pool_recycle`, сделать меньше `wait_timeout`

Задание 4.
===

Если в системе мало памяти и освободить ее невозможно, вызывается функция `out_of_memory`. На этом этапе ей остается только одно — завершить один или несколько процессов.

OOM-Killer «убивает» самые нехорошие процессы и спасает систему от аварийного завершения. Чтобы не приходилось использовать OOM-Killer для завершения PostgreSQL, необходимо установить для `vm.overcommit_memory` значение 2. Это не гарантирует, что OOM-Killer не придется вмешиваться, но снизит вероятность принудительного завершения процесса PostgreSQL.
